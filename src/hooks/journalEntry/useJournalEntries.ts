//Generated by GenerateListHook
import { SelectChangeEvent } from "@mui/material";
import { FormikProps } from "formik";
import { useRouter } from "next/router";
import { useState, useEffect } from "react";
import {
  JournalEntryURLQuery,
  JournalEntryFilterFormDefaultValue,
  JournalEntryModel,
} from "../../interfaces/JournalEntryInterfaces";
import {
  BasicModel,
  SortPair,
  NameCaption,
  SortOptions,
  SortOptionsAsString,
} from "../../interfaces/GeneralInterfaces";
import axiosClient from "../../utils/api";
import {
  getFilterValueFromURL,
  getParamsObject,
  getSortedBy,
  modifySort,
  modifyLimit,
  getFirstItem,
  getAxiosParams,
  supplyMissingNames,
  modifySortAsString,
} from "../../utils/utilities";
import usePromiseAll from "../usePromiseAll";
import { useToggle } from "../useToggle";
import { monthsModel } from "../../utils/constants";
//Generated by GetAdditionalImportBasedOnListVariableName
import { SubAccountTitleModel } from "../../interfaces/SubAccountTitleInterfaces";
const useJournalEntries = (query: Partial<JournalEntryURLQuery>) => {
  const router = useRouter();
  //Generated by CopyAllEnumConstantDeclaration
  //Generated by CopyUsePromiseAllOfThisModel

  const {
    data,
    loading: isRequiredListLoading,
    error: promiseAllError,
  } = usePromiseAll({ subAccountTitles: "/sub-account-titles" });

  const assertedSubAccountTitles =
    data.subAccountTitles as SubAccountTitleModel[];
  const subAccountTitles = assertedSubAccountTitles?.map((item) => ({
    id: item.id,
    name: item.sub_account_title,
  })) as BasicModel[];

  promiseAllError && console.log(promiseAllError);
  const requiredListObject: TRequiredList = {
    subAccountTitles,
    isRequiredListLoading,
  }; //Generated by Build_requiredList
  //Generated by Generate_filterFormDefaultValue
  const filterFormDefaultValue: JournalEntryFilterFormDefaultValue = {
    sub_account_title: [],
    start_date: "",
    end_date: "",
    q: "",
  };
  //Reshape the initial values of the filter form depending on the URL queries
  const filterFormInitialValue: JournalEntryFilterFormDefaultValue =
    getFilterValueFromURL(query, filterFormDefaultValue);
  //This will supply the name key for each array of objects
  if (subAccountTitles) {
    supplyMissingNames(
      subAccountTitles as BasicModel[],
      filterFormInitialValue.sub_account_title
    );
  }
  //Generated by GenerateFilterFormikEvents
  const handleFilterFormSubmit = (
    values: JournalEntryFilterFormDefaultValue
  ) => {
    const params = getParamsObject(
      values,
      filterFormDefaultValue
    ) as Partial<JournalEntryURLQuery>;
    router.push({ pathname: router.pathname, query: params });
  };

  const handleFilterFormReset = (formik: FormikProps<any>) => {
    formik.resetForm({
      values: filterFormDefaultValue,
    });
    router.push({ pathname: router.pathname });
  };
  const formikObject: TFormikFilterFormObject = {
    filterFormDefaultValue,
    filterFormInitialValue,
    handleFilterFormSubmit,
    handleFilterFormReset,
  };
  //Generated by GenerateClientModelSortLimit

  //Generated by GenerateClientSortOptions
  const sortedBy = getSortedBy(query, "-date");
  const sortOptions: SortOptionsAsString = {
    sortedBy,
    sortObject: {
      date: { caption: "Date", asc: "date", desc: "-date" },
      id: { caption: "Most Recent", asc: "id", desc: "-id" },
    },
  };

  const handleJournalEntrySort = (name: string) =>
    modifySortAsString(name, sortOptions, router, query);

  const handleJournalEntryLimitChange = (event: SelectChangeEvent<string>) =>
    modifyLimit(event.target.value, router, query);

  const sortAndLimitObject = {
    limit: getFirstItem(query.limit, "20"),
    sortOptions,
    handleJournalEntrySort,
    handleJournalEntryLimitChange,
  };
  //Generated by GenerateMainListObject
  const [journalEntries, setJournalEntries] = useState<JournalEntryModel[]>([]);
  const [gridLoading, setGridLoading] = useState(true);
  const [recordCount, setRecordCount] = useState(0);

  const fetchJournalEntries = async () => {
    setGridLoading(true);

    try {
      const { data } = await axiosClient.get("/journal-entries/", {
        params: {
          ...getAxiosParams(query, filterFormDefaultValue),
          page: query.page,
          limit: query.limit,
          sort: query.sort,
        },
      });

      if (data.status === "success" || data.data) {
        const rows = data.data.rows || data.data;
        const count = data.data.count || data.totalRecordCount;
        setJournalEntries(rows || []);
        setRecordCount(count || 0);
      }
    } catch (error) {
      console.error(error);
    } finally {
      setGridLoading(false);
    }
  };

  useEffect(() => {
    fetchJournalEntries();
  }, [query]);

  const mainListObject = { journalEntries, gridLoading, recordCount };
  //Generated by GenerateFilterFormToggleObject
  const { toggle: isFilterFormShown, handleToggle: toggleFilterForm } =
    useToggle();
  const toggleObject = { isFilterFormShown, toggleFilterForm };
  //Generated by GenerateListBreadcrumbLinks
  const breadCrumbLinks = [
    { href: "/journal-entries", caption: "Journal Entry List" },
  ];
  return {
    requiredListObject,
    sortAndLimitObject,
    mainListObject,
    formikObject,
    toggleObject,
    breadCrumbLinks,
  };
};
export type TMainListObject = {
  journalEntries: JournalEntryModel[];
  gridLoading: boolean;
  recordCount: number;
};
export type TFormikFilterFormObject = {
  filterFormDefaultValue: JournalEntryFilterFormDefaultValue;
  filterFormInitialValue: JournalEntryFilterFormDefaultValue;
  handleFilterFormSubmit: (values: JournalEntryFilterFormDefaultValue) => void;
  handleFilterFormReset: (formik: FormikProps<any>) => void;
};
export type TJournalEntriesHook = ReturnType<typeof useJournalEntries>;
//Generated by GenerateTRequiredListDeclaration
export type TRequiredList = {
  subAccountTitles: BasicModel[];
  isRequiredListLoading: boolean;
};
export default useJournalEntries;
